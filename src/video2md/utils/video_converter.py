#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Video to Audio Converter Tool
Supports converting various video formats to audio formats for Whisper transcription
"""

import subprocess
from pathlib import Path
from typing import Optional, Union
import logging

# Get logger (don't configure here, let the application configure it)
logger = logging.getLogger(__name__)


class VideoConverter:
    """Video to Audio Converter"""

    # Supported video formats
    SUPPORTED_VIDEO_FORMATS = {
        '.mp4', '.avi', '.mov', '.mkv', '.flv', '.wmv', '.webm',
        '.m4v', '.3gp', '.ogv', '.ts', '.mts', '.m2ts'
    }

    # Supported audio formats
    SUPPORTED_AUDIO_FORMATS = {
        '.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a', '.wma'
    }

    def __init__(self):
        """Initialize converter, check if ffmpeg is available"""
        self._check_ffmpeg()

    def _check_ffmpeg(self):
        """Check if ffmpeg is installed on the system"""
        try:
            subprocess.run(['ffmpeg', '-version'],
                           capture_output=True, check=True)
            logger.info("FFmpeg check passed")
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.error("FFmpeg not found. Please install FFmpeg to use VideoConverter.")
            raise RuntimeError(
                "FFmpeg not installed or unavailable. Please install FFmpeg first: brew install ffmpeg (macOS)")

    def is_video_file(self, file_path: Union[str, Path]) -> bool:
        """Check if file is a supported video format"""
        return Path(file_path).suffix.lower() in self.SUPPORTED_VIDEO_FORMATS

    def is_audio_file(self, file_path: Union[str, Path]) -> bool:
        """Check if file is a supported audio format"""
        return Path(file_path).suffix.lower() in self.SUPPORTED_AUDIO_FORMATS

    def video_to_audio(self,
                       input_path: Union[str, Path],
                       output_path: Optional[Union[str, Path]] = None,
                       output_dir: Optional[Union[str, Path]] = None,
                       audio_format: str = 'wav',
                       sample_rate: int = 16000,
                       channels: int = 1,
                       overwrite: bool = True) -> str:
        """
        Convert video file to audio file

        Args:
            input_path: Input video file path
            output_path: Output audio file path (optional, auto-generated by default)
            output_dir: Output directory (optional, default 'whisper_output')
            audio_format: Audio format ('wav', 'mp3', 'flac', 'aac')
            sample_rate: Sample rate (default 16000Hz, suitable for speech recognition)
            channels: Number of channels (1=mono, 2=stereo)
            overwrite: Whether to overwrite existing files

        Returns:
            Path of the converted audio file

        Raises:
            FileNotFoundError: Input file does not exist
            ValueError: Unsupported format or parameter error
            RuntimeError: Error during conversion process
        """
        input_path = Path(input_path)

        # Check input file
        if not input_path.exists():
            raise FileNotFoundError(f"Input file does not exist: {input_path}")

        if not self.is_video_file(input_path):
            raise ValueError(f"Unsupported video format: {input_path.suffix}")

        # Generate output path
        if output_path is None:
            # Determine output directory
            if output_dir is None:
                output_dir = Path("whisper_output")  # Default output directory
            else:
                output_dir = Path(output_dir)

            # Ensure output directory exists
            output_dir.mkdir(parents=True, exist_ok=True)

            # Generate output filename
            output_filename = f"{input_path.stem}.{audio_format}"
            output_path = output_dir / output_filename
        else:
            output_path = Path(output_path)
            # If full path is specified, ensure directory exists
            output_path.parent.mkdir(parents=True, exist_ok=True)

        # Check if output file already exists
        if output_path.exists() and not overwrite:
            logger.warning(f"Output file already exists: {output_path}")
            return str(output_path)

        # Build ffmpeg command
        cmd = [
            'ffmpeg',
            '-loglevel', 'error',         # Only show errors to reduce output buffering issues
            '-y' if overwrite else '-n',  # Overwrite option
            '-i', str(input_path),        # Input file
            '-vn',                        # No video stream processing
            '-acodec', self._get_audio_codec(audio_format),
            '-ar', str(sample_rate),      # Sample rate
            '-ac', str(channels),         # Number of channels
            str(output_path)              # Output file
        ]

        logger.info(
            f"Starting conversion: {input_path.name} -> {output_path.name}")
        logger.debug(f"FFmpeg command: {' '.join(cmd)}")

        try:
            # Execute conversion with timeout (10 minutes should be enough for most files)
            # Use DEVNULL to avoid buffering issues with stderr/stdout
            result = subprocess.run(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=True,
                timeout=600  # 10 minutes timeout
            )

            # Check output file
            if not output_path.exists():
                raise RuntimeError(
                    "Conversion completed but output file not generated")

            logger.info(f"Conversion successful: {output_path}")
            return str(output_path)

        except subprocess.TimeoutExpired as e:
            error_msg = f"FFmpeg conversion timed out after 600 seconds"
            logger.error(error_msg)
            raise RuntimeError(error_msg) from e

        except subprocess.CalledProcessError as e:
            error_msg = f"FFmpeg conversion failed with exit code {e.returncode}"
            logger.error(error_msg)
            raise RuntimeError(error_msg) from e

    def _get_audio_codec(self, audio_format: str) -> str:
        """Get audio codec based on audio format"""
        codec_map = {
            'wav': 'pcm_s16le',
            'mp3': 'libmp3lame',
            'flac': 'flac',
            'aac': 'aac',
            'ogg': 'libvorbis',
            'm4a': 'aac'
        }
        return codec_map.get(audio_format.lower(), 'pcm_s16le')


def convert_video_to_audio(input_path: Union[str, Path],
                           output_path: Optional[Union[str, Path]] = None,
                           output_dir: Optional[Union[str, Path]] = None,
                           **kwargs) -> str:
    """
    Convenience function: Convert video to audio

    Args:
        input_path: Input video file path
        output_path: Output audio file path (optional)
        output_dir: Output directory (optional, default 'whisper_output')
        **kwargs: Other conversion parameters

    Returns:
        Path of the converted audio file
    """
    converter = VideoConverter()
    return converter.video_to_audio(input_path, output_path, output_dir, **kwargs)
